---
title: "jan2021"
output:
  pdf_document: default
  html_document: default
date: "2024-10-27"
---

# 1. Graphical Models (6 p) - Using the IC Algorithn

## Overview of the IC Algorithm

#### The IC algorithm consists of three main steps:

1.  *Skeleton Discovery*: Construct an undirected graph that represents dependencies between variables.
2.  *Edge Orientation with V-Structures*: Identify causal directions by finding V-structures (patterns where A--\> B \<-- C with no edge between A and C).
3.  *Propagation of Orientation*: Further orient edges using rules to avoid cycles and preserve conditional independencies.

```{r}
library(bnlearn)

data("lizards")

lizardsnet<-model2network("[Species][Diameter|Species][Height|Species]") # True DAG
plot(lizardsnet)
plot(cpdag(lizardsnet)) # Plot the true pattern

# Independence if p-value is > 0.05

# Skeleton discovery
ci.test(x = "Diameter", y = "Species", data = lizards)  # Keep edge D-S. (Not independent given empty set)
ci.test(x = "Diameter", y = "Height", data = lizards)   # Remove edge D-H. (Independent given empty set)
ci.test(x = "Height", y = "Species", data = lizards)    # Keep edge H-S. (Not independent given empty set)

# The skeleton now looks like this:
currmod = model2network("[Species][Diameter|Species][Height|Species]")
plot(cpdag(currmod))

# Edge Orientation with V-Structures
# Investigate non adjacent vairables
ci.test(x = "Diameter", y = "Height", z = "Species", data = lizards) # D and H are independent given S

# Since this test showed that D and H are conditionally independent, 
# we choose S as an unsheilded collider: D --> S <-- H


plot(model2network("[Diameter][Height][Species|Diameter:Height]"))
```

# 2. Hidden Markov Models (7 p)

```{r}
library(bnlearn)
library(gRain)
hmm <- model2network("[z0][x0|z0][z1|z0][x1|z1][z2|z1][x2|z2][z3|z2][x3|z3]") # True DAG

states = c("1","2","3","4","5","6","7","8","9","10")
symbols = c("1","2","3","4","5","6","7","8","9","10")

transitionProb = matrix(0,nrow = 10, ncol = 10)
for (j in 1:10) {
  transitionProb[j,j] = 0.5
  transitionProb[j,j%%10 +1 ] = 0.5
}

emissionProb = matrix(0,nrow = 10, ncol = 10)
for (j in 1:10) {
  for (i in 1:5) {
    emissionProb[(j+i-4)%%10+1,j] = 0.2
  }
}

###### Hidden states ######
cptZ0 = rep(0.1,10)
dim(cptZ0) = c(10)
dimnames(cptZ0) = list(states)

cptZ1 = transitionProb
dim(cptZ1) = c(10,10)
dimnames(cptZ1) = list("z1" = states, "z0" = states)


cptZ2 = transitionProb
dim(cptZ2) = c(10,10)
dimnames(cptZ2) = list("z2" = states, "z1" = states)

cptZ3 = transitionProb
dim(cptZ3) = c(10,10)
dimnames(cptZ3) = list("z3" = states, "z2" = states)
#############################

###### observed states ######
cptX0 = emissionProb
dim(cptX0) = c(10,10)
dimnames(cptX0) = list("x0" = symbols, "z0" = states)

cptX1 = emissionProb
dim(cptX1) = c(10,10)
dimnames(cptX1) = list("x1" = symbols, "z1" = states)

cptX2 = emissionProb
dim(cptX2) = c(10,10)
dimnames(cptX2) = list("x2" = symbols, "z2" = states)

cptX3 = emissionProb
dim(cptX3) = c(10,10)
dimnames(cptX3) = list("x3" = symbols, "z3" = states)
#############################

nodes = c("z0", "z1", "z2", "z3", "x0", "x1", "x2", "x3")
hmmfit = custom.fit(hmm, list(z0=cptZ0, z1=cptZ1, z2=cptZ2, z3=cptZ3, x0=cptX0, x1=cptX1, x2=cptX2, x3=cptX3))
compiledgrain = compile(as.grain(hmmfit))


querygrain(setEvidence(compiledgrain,nodes = c("x0", "x2"), states = c("1","3")), nodes = "z0")$z0
querygrain(setEvidence(compiledgrain,nodes = c("x0", "x2"), states = c("1","3")), nodes = "z1")$z1
querygrain(setEvidence(compiledgrain,nodes = c("x0", "x2"), states = c("1","3")), nodes = "z2")$z2
querygrain(setEvidence(compiledgrain,nodes = c("x0", "x2"), states = c("1","3")), nodes = "z3")$z3

```

